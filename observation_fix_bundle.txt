

===== ./engine/runtime-engine.js =====

import * as acorn from "acorn";
import { ContextLifecycleWorkflow } from "../runtime-time/context-lifecycle-workflow.js";
import { VariableResolutionWorkflow } from "../runtime-time/variable-resolution-workflow.js";
import { ControlFlowWorkflow } from "../runtime-time/control-flow-workflow.js";
import { TerminalRenderer as T } from "../ui/terminal-renderer.js";

export class RuntimeEngine {
    lastValue = undefined;
    
  constructor() {
    this.contexts = new ContextLifecycleWorkflow();
    this.variables = new VariableResolutionWorkflow();
    this.controlFlow = new ControlFlowWorkflow(this);
  }

  // ───────────────────────────────
  // Lifecycle
  // ───────────────────────────────
  init() {
    this.contexts.initializeGlobalContext();
  }

  terminate() {
    this.contexts.terminate();
  }

  // ───────────────────────────────
  // Environment Access
  // ───────────────────────────────
  getCurrentEnvs() {
    const ctx = this.contexts.currentContext();
    return {
      lexical: ctx.lexicalEnv,
      variable: ctx.variableEnv,
    };
  }

  define(name, value, kind, envs) {
    this.variables.define(name, value, kind, envs);
    this.renderSnapshot(`define ${name} = ${JSON.stringify(value)} (${kind})`);
  }

  resolve(name) {
    const envs = this.getCurrentEnvs();
    return this.variables.resolve(name, envs);
  }

  pushBlockEnv() {
    const ctx = this.contexts.currentContext();
    ctx.lexicalEnv = new ctx.lexicalEnv.constructor(ctx.lexicalEnv);
  }

  popBlockEnv() {
    const ctx = this.contexts.currentContext();
    ctx.lexicalEnv = ctx.lexicalEnv.outer;
  }

  // ───────────────────────────────
  // Execution
  // ───────────────────────────────
  run(code) {
    const ast = acorn.parse(code, { ecmaVersion: "latest" });
    this.controlFlow.execute(ast.body);
  }

  // ───────────────────────────────
  // Snapshot
  // ───────────────────────────────
  renderSnapshot(action) {
    const ctx = this.contexts.currentContext();
    const envs = this.getCurrentEnvs();
    const frames = this.contexts.callStack.printStack();

    console.log(T.header(`ACTION: ${action}`));

    console.log(T.block("CALL STACK", T.formatCallStack(frames)));

    console.log(T.block("LexicalEnv Chain", T.formatEnvChain(envs.lexical)));


    console.log(T.block("VariableEnv Chain", T.formatEnvChain(envs.variable)));

    console.log("-".repeat(40));
  }
}


===== ./runtime-time/control-flow-workflow.js =====

import { ExpressionEvaluator } from "../runtime-time/expression-evaluator.js";
import { FunctionObject } from "./function-object.js";

export class ControlFlowWorkflow {
  constructor(runtime) {
    this.runtime = runtime;
    this.evaluator = new ExpressionEvaluator(runtime);
  }

  execute(body) {
    for (const node of body) {
      const result = this.dispatch(node);

      // stop execution if return reached
      if (result && result.type === "return") {
        return result;
      }
    }
  }

  dispatch(node) {
    if (node.type === "FunctionDeclaration") {
      return this.handleFunctionDeclaration(node);
    }

    if (node.type === "VariableDeclaration") {
      return this.handleVarDecl(node);
    }

    if (node.type === "BlockStatement") {
      return this.handleBlock(node);
    }

    if (node.type === "ReturnStatement") {
      const value = node.argument
        ? this.evaluator.evaluate(node.argument)
        : undefined;

      return { type: "return", value };
    }
  }

  handleVarDecl(node) {
    const envs = this.runtime.getCurrentEnvs();

    for (const decl of node.declarations) {
      const name = decl.id.name;
      const value = decl.init ? this.evaluator.evaluate(decl.init) : undefined;

      this.runtime.define(name, value, node.kind, envs);
    }
  }

  handleBlock(node) {
    this.runtime.pushBlockEnv();

    for (const stmt of node.body) {
      const result = this.dispatch(stmt);

      // Bubble return upward
      if (result && result.type === "return") {
        this.runtime.popBlockEnv();
        return result;
      }
    }

    this.runtime.popBlockEnv();
  }

  handleFunctionDeclaration(node) {
  const name = node.id.name;
  const params = node.params.map(p => p.name);
  const body = node.body;
  const closure = this.runtime.getCurrentEnvs().lexical;

  const fn = new FunctionObject(name, params, body, closure);

  // bind function into lexical environment (not var env)
  closure.define(name, fn);

  this.runtime.renderSnapshot(`define function ${name}`);
  return fn;
}

}


===== ./runtime-time/expression-evaluator.js =====

export class ExpressionEvaluator {
  constructor(runtime) {
    this.runtime = runtime;
  }

  evaluate(expr) {
    if (!expr) return undefined;

    switch (expr.type) {
      case "Literal":
        return expr.value;

      case "Identifier":
        return this.runtime.resolve(expr.name);

      case "BinaryExpression":
        return this.evalBinary(expr);

        case "AssignmentExpression":
  return this.evalAssignment(expr);


      default:
        return undefined;
    }
  }

  evalBinary(expr) {
    const left = this.evaluate(expr.left);
    const right = this.evaluate(expr.right);

    switch (expr.operator) {
      case "+":
        return left + right;
      case "-":
        return left - right;
      case "*":
        return left * right;
      case "/":
        return left / right;
      case "%":
        return left % right;

      case "==":
        return left == right;
      case "===":
        return left === right;
      case "!=":
        return left != right;
      case "!==":
        return left !== right;

      case "<":
        return left < right;
      case "<=":
        return left <= right;
      case ">":
        return left > right;
      case ">=":
        return left >= right;

      default:
        return undefined;
    }
  }

  evalAssignment(expr) {
  const { operator, left, right } = expr;

  if (left.type !== "Identifier") {
    throw new Error("UC06 supports assignment to simple identifiers only");
  }

  const name = left.name;
  const value = this.evaluate(right);

  if (operator === "=") {
    const envs = this.runtime.getCurrentEnvs();
    this.runtime.variables.update(name, value, envs);
    return value;
  }

  throw new Error(`Operator ${operator} not implemented in UC06`);
}

}
