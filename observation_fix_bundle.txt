

===== ./runtime-time/control-flow-workflow.js =====

import { ExpressionEvaluator } from "../runtime-time/expression-evaluator.js";

export class ControlFlowWorkflow {
  constructor(runtime) {
    this.runtime = runtime;
    this.evaluator = new ExpressionEvaluator(runtime);
  }

  execute(body) {
    for (const node of body) {
      this.dispatch(node);
    }
  }

  dispatch(node) {
    if (node.type === "VariableDeclaration") {
      return this.handleVarDecl(node);
    }

    if (node.type === "BlockStatement") {
      return this.handleBlock(node);
    }

if (node.type === "ExpressionStatement") {
  const value = this.evaluator.evaluate(node.expression);
  this.runtime.lastValue = value;     // <-- NEW LINE
  return value;
}


  }

  handleVarDecl(node) {
    const envs = this.runtime.getCurrentEnvs();

    for (const decl of node.declarations) {
      const name = decl.id.name;
      const value = decl.init ? this.evaluator.evaluate(decl.init) : undefined;

      this.runtime.define(name, value, node.kind, envs);
    }
  }

  handleBlock(node) {
    this.runtime.pushBlockEnv();
    for (const stmt of node.body) {
      this.dispatch(stmt);
    }
    this.runtime.popBlockEnv();
  }
}


===== ./runtime-time/expression-evaluator.js =====

export class ExpressionEvaluator {
  constructor(runtime) {
    this.runtime = runtime;
  }

  evaluate(expr) {
    if (!expr) return undefined;

    switch (expr.type) {
      case "Literal":
        return expr.value;

      case "Identifier":
        return this.runtime.resolve(expr.name);

      case "BinaryExpression":
        return this.evalBinary(expr);

      default:
        return undefined;
    }
  }

  evalBinary(expr) {
    const left = this.evaluate(expr.left);
    const right = this.evaluate(expr.right);

    switch (expr.operator) {
      case "+":
        return left + right;
      case "-":
        return left - right;
      case "*":
        return left * right;
      case "/":
        return left / right;
      case "%":
        return left % right;

      case "==":
        return left == right;
      case "===":
        return left === right;
      case "!=":
        return left != right;
      case "!==":
        return left !== right;

      case "<":
        return left < right;
      case "<=":
        return left <= right;
      case ">":
        return left > right;
      case ">=":
        return left >= right;

      default:
        return undefined;
    }
  }
}


===== ./runtime-time/variable-resolution-workflow.js =====

import { LexicalEnvironment } from "../runtime-space/lexical-environment.js";
import { VariableEnvironment } from "../runtime-space/variable-environment.js";
import { ScopeChain } from "../runtime-space/scope-chain.js";
import { EnvironmentRouter } from "../runtime-time/environment-router.js";

export class VariableResolutionWorkflow {
  constructor() {
    // Global base environments
    this.globalLexical = new LexicalEnvironment();
    this.globalVariable = new VariableEnvironment();

    // Router decides where let/var/const go
    this.router = new EnvironmentRouter(
      this.globalLexical,
      this.globalVariable
    );
  }

  define(name, value, kind, envs) {
    const target = this.router.select(kind, envs);
    target.define(name, value);
  }

  resolve(name, envs) {
    try {
      // lexical first
      return ScopeChain.lookup(name, envs.lexical);
    } catch {
      // fallback to var space
      try {
        return ScopeChain.lookup(name, envs.variable);
      } catch {
        return undefined;
      }
    }
  }
}


===== ./runtime-space/lexical-environment.js =====

export class LexicalEnvironment {
  constructor(outer = null) {
    this.environmentRecord = {};
    this.outer = outer;
  }

  define(name, value) {
    this.environmentRecord[name] = value;
  }

  lookup(name) {
    if (name in this.environmentRecord) return this.environmentRecord[name];
    if (this.outer) return this.outer.lookup(name);
    return undefined;
  }
}


===== ./runtime-space/variable-environment.js =====

export class VariableEnvironment {
  constructor(outer = null) {
    this.environmentRecord = {};
    this.outer = outer;
  }

  define(name, value) {
    this.environmentRecord[name] = value;
  }

  lookup(name) {
    if (name in this.environmentRecord) return this.environmentRecord[name];
    if (this.outer) return this.outer.lookup(name);
    return undefined;
  }
}
